#define F_CPU 1000000UL

#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include <avr/eeprom.h>
#include <stdio.h>

#define BUT1        0x04
#define BUT2        0x08
#define LONG_PRESS  300
#define RED         0x80
#define GREEN       0x20
#define BLUE        0x10
#define DIGITS      4

#define BAUD        4800UL
#define UBRR_value  ((F_CPU / (16 * BAUD)) - 1)

int hours = 0;
int minutes = 0;
int mode = 0;
int dp = 0;

int digits[DIGITS] = {0};
int debounce1 = 0;
int debounce2 = 0;
int ignr_d = 0;
int long_press = 1;

int timerr = 0;
int sec_t = 0;
int min_t = 0;

int blink_count = 0;
int blinking_enable = 0;
int time_changed = 0;

uint8_t EEMEM save_hours;
uint8_t EEMEM save_minutes;

void Button_Init(void) {
	MCUCR |= (1 << ISC01);
    MCUCR |= (1 << ISC11);
    GICR |= (1 << INT0) | (1 << INT1);
}

void Timer_Counter_2_Init(void) {
	TCCR2 = (1 << WGM21) | (1 << CS22) | (1 << CS21);
    OCR2 = 12;
    TIMSK |= (1 << OCIE2);
}

void Timer_Counter_1_Init(void) {
	TCCR1B |= (1 << WGM12) | (1 << CS11) | (1 << CS10);
    OCR1A = 14;
    TIMSK |= (1 << OCIE1A);
}

void UART_Init(void) {
    UBRRL = UBRR_value;
    UBRRH = (UBRR_value >> 8);
    UCSRB = (1 << TXEN) | (1 << RXEN);
    UCSRC = (1 << URSEL) | (1 << UCSZ1) | (1 << UCSZ0);
}

void UART_send(unsigned char value) {
    while (!(UCSRA & (1 << UDRE)));
    UDR = value;
}

void UART_send_str(unsigned char *str) {
    while (*str != '\0') {
        UART_send(*str);
        str++;
    }
}

void time2eeprom(void) {
    eeprom_update_byte(&save_hours, (uint8_t)hours);
    eeprom_update_byte(&save_minutes, (uint8_t)minutes);
}

void timefreeprom(void) {
    hours = eeprom_read_byte(&save_hours);
    minutes = eeprom_read_byte(&save_minutes);

    if (hours > 23) hours = 0;
    if (minutes > 59) minutes = 0;
}

void dec2digit(int dec) {
    switch (dec) {
        case 0: PORTC = 0b01011111; break;
        case 1: PORTC = 0b00000110; break;
        case 2: PORTC = 0b00111011; break;
        case 3: PORTC = 0b00101111; break;
        case 4: PORTC = 0b01100110; break;
        case 5: PORTC = 0b01101101; break;
        case 6: PORTC = 0b01111101; break;
        case 7: PORTC = 0b00000111; break;
        case 8: PORTC = 0b01111111; break;
        case 9: PORTC = 0b01101111; break;
        default: PORTC = 0b00000000;
    }
}

void update_digits() {
    if (mode == 3) {
        digits[0] = min_t / 10;
        digits[1] = min_t % 10;
        digits[2] = sec_t / 10;
        digits[3] = sec_t % 10;
    } else {
        digits[0] = hours / 10;
        digits[1] = hours % 10;
        digits[2] = minutes / 10;
        digits[3] = minutes % 10;
    }
}

void update_leds() {
    if (mode == 0) {
		PORTD = RED;
		blinking_enable = 1;
	} else if (mode == 1) {
		PORTD = BLUE;
		dp = 1;
	} else if (mode == 2) {
		PORTD = GREEN;
		dp = 1;
    } else if (mode == 3) {
        if (timerr)
			PORTD = RED | BLUE;
		else 
			PORTD = RED | GREEN;
			dp = 1;
    }
}

void handle_short_press(int button) {
	
    if (button == 1) {
        if (mode == 1 && !ignr_d) {
			
            hours = (hours + 1) % 24;
			
        } else if (mode == 2) {
			
            minutes = (minutes + 1) % 60;
			
        } else if (mode == 3 && !timerr) {
			
            sec_t++;
            if (sec_t > 59) {
                sec_t = 0;
                min_t++;
                if (min_t > 59) min_t = 0;
            }
        }
		
			 
			blink_count = 0; 
			
		
    } else if (button == 2) {
        if (mode == 1) {
			
            hours = (hours == 0) ? 23 : hours - 1;
			
        } else if (mode == 2) {
			
            minutes = (minutes == 0) ? 59 : minutes - 1;
			
        } else if (mode == 3 && !timerr && !ignr_d) {
			
            if (min_t <= 0 && sec_t <= 0) {
                sec_t = 0; 
				min_t = 0;
				
            } else if (sec_t == 0 && min_t > 0) {
                min_t--; sec_t = 59;
				
            } else {
                sec_t--;
            }
        }
			
			 
			blink_count = 0; 
			
		
    }
}

void handle_long_press(int button) {
	
    if (button == 0) {
		
        mode = (mode != 3) ? 3 : 0;
        update_leds();
        long_press = 0;
        ignr_d = 1;
		
    } else if (button == 1 && !(mode == 3)) {
		
        mode = (mode + 1) % 3;
		 
 		blink_count = 0; 
		
        update_leds();
        long_press = 0;
        ignr_d = 1;
		
    } else if (button == 1 && mode == 3 && !timerr) {
		
        sec_t++;
        if (sec_t > 59) {
            sec_t = 0;
            min_t++;
            if (min_t > 59) {
                min_t = 0;
                sec_t = 0;
            }
        }
		
        long_press = 1;
        ignr_d = 1;
		
    } else if (button == 2 && mode == 3) {
		
        timerr = !timerr;
		
        update_leds();
        long_press = 0;
        ignr_d = 1;
		
    }
}


void led_blinking_handler() {
	static ms_blink = 0;
	
	ms_blink++;
	if (ms_blink >= 500) {
		ms_blink = 0;

		if (blinking_enable && time_changed) {
			int max_blinks = (hours == 0 ? 24 : hours);

			if (blink_count < max_blinks) {
				if (blink_count % 2 == 0)
					PORTD |= GREEN | BLUE;
				else
					update_leds();
				blink_count++;
			} else {
			blinking_enable = 0;
			}
		}
	}
}

ISR(TIMER2_COMP_vect) {
    static int cntr = 0;
    static int count = 0;

    PORTC = 0x00;
    PORTA = 0x00;
    dec2digit(digits[cntr]);

    if (cntr == 1 && dp) PORTC |= 0x80;

    PORTA |= (1 << (cntr + 4));
    cntr = (cntr + 1) % 4;

    if (debounce1 > 0) {
        debounce1--;
        if (debounce1 == 0) handle_short_press(1);
    }

    if (debounce2 > 0) {
        debounce2--;
        if (debounce2 == 0) handle_short_press(2);
    }



    if ((PIND & BUT1) && (PIND & BUT2)) {
		
        count++;
        if (count >= LONG_PRESS && long_press) handle_long_press(0);
		
    } else if ((PIND & BUT1) && !(PIND & BUT2)) {
		
        count++;
        if (count >= LONG_PRESS && long_press) handle_long_press(1);
		
    } else if (!(PIND & BUT1) && (PIND & BUT2)) {
		
        count++;
        if (count >= LONG_PRESS && long_press) handle_long_press(2);
		
    } else {
        count = 0;
        long_press = 1;
        ignr_d = 0;
    }
}

ISR(TIMER1_COMPA_vect) {
	static int seconds = 0;
    static int milliseconds = 0;
	static int ms = 0;

    if (milliseconds % 500 == 0)
		if (mode == 0) {
			dp = !dp;
		}

    if (mode != 1 && mode != 2) {
		milliseconds++;
        if (milliseconds >= 1000) {
			milliseconds = 0;
            seconds++;
            if (seconds >= 60) {
                seconds = 0;
                minutes++;
                if (minutes >= 60) {
                    minutes = 0;
                    hours++;
                    if (hours >= 24) hours = 0;
						
                     time_changed = 1;
                     
                }

                time2eeprom();

                char time_str[20];
                sprintf(time_str, "Time: %02d:%02d:%02d\r\n", hours, minutes, seconds);
                UART_send_str((unsigned char *)time_str);
            }
        }

		if (timerr && (min_t > 0 || sec_t > 0)) {
			ms++;
			if (ms >= 1000) {
				ms = 0;
				if (sec_t == 0 && min_t > 0) {
					min_t--;
					sec_t = 59;
				} else {
					sec_t--;
				}
			}
		}	
	} 
	
    led_blinking_handler();
}

ISR(INT0_vect) {
    if (!ignr_d) debounce1 = 52;
}

ISR(INT1_vect) {
    if (!ignr_d) debounce2 = 52;
}

int main(void) {
    DDRC = 0xFF;
    DDRA = 0xF0;
    DDRD = 0xB0;
	
	update_leds();
	
	Button_Init();
	
	Timer_Counter_2_Init();
	
	Timer_Counter_1_Init();
	
    UART_Init();

    timefreeprom();
	
    sei();

    while (1) {
        update_digits();
    }
}
